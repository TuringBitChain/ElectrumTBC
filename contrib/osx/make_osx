#!/usr/bin/env bash
#
# Includes selected lines from Electrum Core on 2022/04/13. Electrum Core license
# (follows this paragraph) applies to the copied code, Bitcoin SV license applies to any
# subsequent modifications.
#
# ------- >8 -- Electrum Core license as of 2022/04/13 -- 8< -------
#
# The MIT License (MIT)
#
# Permission is hereby granted, free of charge, to any person obtaining
# a copy of this software and associated documentation files (the
# "Software"), to deal in the Software without restriction, including
# without limitation the rights to use, copy, modify, merge, publish,
# distribute, sublicense, and/or sell copies of the Software, and to
# permit persons to whom the Software is furnished to do so, subject to
# the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
#
# ------- >8 -- Electrum Core license as of 2022/04/13 -- 8< -------
#

set -e

CONTRIB_OSX=$(dirname $(realpath "$0" 2> /dev/null || grealpath "$0"))
echo "CONTRIB_OSX=$CONTRIB_OSX"
CONTRIB="$CONTRIB_OSX/.."
PROJECT_ROOT="$CONTRIB/.."

test -n "$CONTRIB_OSX" -a -d "$CONTRIB_OSX" || exit

. "$CONTRIB"/build_tools_util.sh # functions we use below

cd $PROJECT_ROOT

export PYTHONHASHSEED=22

# Parameterize.
PYTHON_VERSION=3.10.0
BUILDDIR=/tmp/electrum-sv-build
PACKAGE=ElectrumSV
GIT_REPO_ACCT=https://github.com/electrumsv
GIT_REPO=$GIT_REPO_ACCT/electrumsv


python3 -c "import sys; assert sys.version_info >= (${PYTHON_VERSION//./,})" > /dev/null 2>&1 || fail "Please ensure Python 3.10 is the default 'python3' command and it is later than Python $PYTHON_VERSION"

which xcodebuild > /dev/null 2>&1 || fail "Please install Xcode and xcode command line tools to continue"

which msgfmt > /dev/null 2>&1 || fail "Please install xgettext.  For brew users: brew install gettext && brew link gettext --force"

brew upgrade sqlite3

# Code Signing: See https://developer.apple.com/library/archive/documentation/Security/Conceptual/CodeSigningGuide/Procedures/Procedures.html
APP_SIGN=""
if [ -n "$1" ]; then
    # Test the identity is valid for signing by doing this hack. There is no other way to do this.
    cp -f /bin/ls ./CODESIGN_TEST
    codesign -s "$1" --dryrun -f ./CODESIGN_TEST > /dev/null 2>&1
    res=$?
    rm -f ./CODESIGN_TEST
    if ((res)); then
        fail "Code signing identity \"$1\" appears to be invalid."
    fi
    unset res
    APP_SIGN="$1"
    info "Code signing enabled using identity \"$APP_SIGN\""
else
    warn "Code signing DISABLED. Specify a valid macOS Developer identity installed on the system as the first argument to this script to enable signing."
fi

function DoCodeSignMaybe { # ARGS: infoName fileOrDirName codesignIdentity
    infoName="$1"
    file="$2"
    identity="$3"
    deep=""
    if [ -z "$identity" ]; then
        # we are ok with them not passing anything; master script calls us unconditionally even if no identity is specified
        return
    fi
    if [ -d "$file" ]; then
        deep="--deep"
    fi
    if [ -z "$infoName" ] || [ -z "$file" ] || [ -z "$identity" ] || [ ! -e "$file" ]; then
        fail "Argument error to internal function DoCodeSignMaybe()"
    fi
        hardened_arg="--entitlements=contrib/osx/entitlements.plist -o runtime"

    info "Code signing ${infoName}..."
    codesign -f -v $deep -s "$identity" $hardened_arg "$file" || fail "Could not code sign ${infoName}"
}

rm -rf ./dist

rm  -rf $BUILDDIR > /dev/null 2>&1
mkdir $BUILDDIR

info "Activating virtualenv $BUILDDIR/venv"
python3 -m venv $BUILDDIR/venv
source $BUILDDIR/venv/bin/activate

info "Installing some build-time deps for compilation..."
brew install autoconf automake libtool gettext coreutils pkgconfig

python3 -m pip install -U pip wheel

info "Building PyInstaller."
PYINSTALLER_REPO="https://github.com/pyinstaller/pyinstaller.git"
PYINSTALLER_COMMIT="3940e5fc5f9e02bce9f1af53c70a42db81071381"
# TODO This is the latest commit that passes pyinstaller's CI.

# TODO(1.4.0) MacOS code signing, issue#903. Pyinstaller apparently changed their code-signing
#     behaviour we likely need to address before release.
#     (https://github.com/pyinstaller/pyinstaller/pull/5581)
(
    if [ -f "$BUILDDIR/pyinstaller/PyInstaller/bootloader/Darwin-64bit/runw" ]; then
        info "pyinstaller already built, skipping"
        exit 0
    fi
    ELECTRUM_COMMIT_HASH=$(git rev-parse HEAD)
    pushd "$BUILDDIR"
    rm -rf pyinstaller
    mkdir pyinstaller
    cd pyinstaller
    # Shallow clone
    git init
    git remote add origin $PYINSTALLER_REPO
    git fetch --depth 1 origin $PYINSTALLER_COMMIT
    git checkout -b pinned "${PYINSTALLER_COMMIT}^{commit}"
    rm -fv PyInstaller/bootloader/Darwin-*/run* || true
    # add reproducible randomness. this ensures we build a different bootloader for each commit.
    # if we built the same one for all releases, that might also get anti-virus false positives
    echo "const char *electrum_tag = \"tagged by Electrum@$ELECTRUM_COMMIT_HASH\";" >> ./bootloader/src/pyi_main.c
    pushd bootloader
    # compile bootloader
    python3 ./waf all CFLAGS="-static"
    popd
    # sanity check bootloader is there:
    [[ -e "PyInstaller/bootloader/Darwin-64bit/runw" ]] || fail "Could not find runw in target dir!"
    popd
) || fail "PyInstaller build failed"

info "Installing PyInstaller requirements."
python3 -m pip install --no-build-isolation --no-dependencies --no-warn-script-location \
    -Ir "$BUILDDIR/pyinstaller/requirements.txt" || fail "Could not install requirements"

info "Installing PyInstaller."
python3 -m pip install --no-build-isolation --no-dependencies --no-warn-script-location \
    "$BUILDDIR/pyinstaller" || fail "Could not install requirements"


info "Using these versions for building $PACKAGE:"
sw_vers
python3 --version
python3 -c "import sqlite3; print(sqlite3.sqlite_version)"

info "Installing ElectrumSV requirements..."
python3 -m pip install -Ir $CONTRIB/deterministic-build/macos-py3.10-requirements-electrumsv.txt || \
fail "Could not install ElectrumSV requirements"

pushd .
if [ ! -f "$PROJECT_ROOT"/electrumsv/libzbar.0.dylib ]; then
    info "Building ZBar dylib..."
    "$CONTRIB"/make_zbar.sh || fail "Could not build ZBar dylib"
else
    info "Skipping ZBar build: reusing already built dylib."
fi
cp "$PROJECT_ROOT"/electrumsv/libzbar.0.dylib "$CONTRIB_OSX"
popd

if [ ! -f "$PROJECT_ROOT"/electrumsv/libusb-1.0.dylib ]; then
    info "Building libusb dylib..."
    "$CONTRIB"/make_libusb.sh || fail "Could not build libusb dylib"
else
    info "Skipping libusb build: reusing already built dylib."
fi
cp "$PROJECT_ROOT"/electrumsv/libusb-1.0.dylib "$CONTRIB_OSX"


info "Installing $PACKAGE..."
python3 -m pip install . > /dev/null || fail "Could not build $PACKAGE"

# --dirty: If there are local modifications, add the '-dirty' text.
# --always: If we are not directly on a tag, add the abbreviated commit.
# --match: Only consider tags matching the given pattern.
# e.g. "sv-1.1.0-12-f3d2d22" (12 commits past tag, and on commit f3d2d22)
RAW_VERSION=`git describe --tags --dirty --always --match sv-*`
#RAW_VERSION=sv-1.4.0b1
# Strip the leading 3 characters from the description, 'sv-1.1.0' -> '1.1.0' (the release version).
VERSION=${RAW_VERSION:3}

info "Using Pyinstaller to build $PACKAGE version $VERSION"
pyinstaller --noconfirm --ascii $CONTRIB_OSX/osx.spec || fail "Could not build binary"

info "Adding bitcoin URI types to Info.plist"
plutil -insert 'CFBundleURLTypes' \
	-xml '<array><dict> <key>CFBundleURLName</key> <string>bitcoin</string> <key>CFBundleURLSchemes</key> <array><string>bitcoin</string></array> </dict></array>' \
	-- dist/$PACKAGE.app/Contents/Info.plist \
	|| fail "Could not add keys to Info.plist. Make sure the program 'plutil' exists and is installed."

info "Hopefully forcing light mode and avoiding dark mode which we do not support."
plutil -insert NSRequiresAquaSystemAppearance -bool YES -- dist/$PACKAGE.app/Contents/Info.plist \
	|| fail "Could not add keys to Info.plist. Make sure the program 'plutil' exists and is installed."

# We (ElectrumSV) created and publish this package with it's local dynamic library, so we should be safe to sign it. Ideally we would
# sign it before we publish the given package, but that is much more work and I am not sure the signing persists into our packaging.
DoCodeSignMaybe "electrumsv-secp256k1" "dist/ElectrumSV.app/Contents/Resources/electrumsv_secp256k1/.dylibs/libgmp.10.dylib" "$APP_SIGN"
DoCodeSignMaybe "app bundle" "dist/${PACKAGE}.app"  "$APP_SIGN"
info "Creating .DMG"
dmgbuild -D PACKAGE=$PACKAGE -s $CONTRIB_OSX/dmg-settings.py "" dist/$PACKAGE-$VERSION.dmg || fail "Could not create .DMG"
DoCodeSignMaybe ".DMG" "dist/${PACKAGE}-${VERSION}.dmg" "$APP_SIGN"

if [ ! -z "$APP_SIGN" ]; then
    if [ ! -z "$APPLE_ID_USER" ]; then
        info "Notarizing .dmg with Apple's central server..."
        "$CONTRIB_OSX/notarize_file.sh" "dist/${PACKAGE}-${VERSION}.dmg" || fail "Could not notarize binary."
    else
        warn "AppleID details not set! Skipping Apple notarization."
    fi
fi

if [ -z "$APP_SIGN" ]; then
    warn "App was built successfully but was not code signed."
    warn "To sign, specify a valid code signing identity as the first argument to this script."
fi
